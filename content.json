{"meta":{"title":"Karma's Blog","subtitle":"無財作力，少有斗智，既饒爭時，此其大經也。","description":null,"author":"Karma","url":"https://karmalove.github.io","root":"/"},"pages":[{"title":"","date":"2019-03-19T08:07:20.498Z","updated":"2019-03-19T08:07:20.498Z","comments":false,"path":"tags/index.html","permalink":"https://karmalove.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-19T08:08:53.355Z","updated":"2019-03-19T08:08:53.355Z","comments":false,"path":"categories/index.html","permalink":"https://karmalove.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"面试总结","slug":"android-meet","date":"2019-08-06T09:14:57.000Z","updated":"2019-08-06T09:17:12.807Z","comments":true,"path":"2019/08/06/android-meet/","link":"","permalink":"https://karmalove.github.io/2019/08/06/android-meet/","excerpt":"","text":"面试总结Java方面1.HashMap和HashTable的区别 通过HashMap和HashTable的源码去分析 2.Java垃圾回收机制 理解JVM，内存划分———方法区、内存栈、【虚拟机栈、本地方法栈、程序计数器（线程私有）】。理解回收算法：标记清除算法、可达性分析算法、标记整理算法、复制算法、分代算法 3.类加载机制 涉及热修复相关问题 4.线程和线程池、并发、锁等一系列问题 如何自定义一个线程池？ 5.弱引用、软引用区别6.int、Integer区别 主要考值传递和引用传递问题 7.手写设计模式 1.单例模式2.生产者/消费者模式3.观察者模式4.适配器模式5.策略模式6.建造者模式+工厂模式7.MVC、MVP、MVVM区别 8.数据结构 1.平衡二叉树、二叉查找数、红黑树2.HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。3.ArrayList和LinkedList的区别4..Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap 9.算法 Android方面1.activity、service、fragment、BroadcastReceiver相关知识点2.自定义view3.事件分发机制4.消息分发机制5.Binder机制，进程通信6.动态权限适配、换肤实现原理7.SharedPreference实现原理，能否跨进程？8.性能优化问题8.1、UI优化8.2、内存优化8.3、响应速度优化8.4、其他性能优化9.网络框架OkHttp、Retrofit的实现原理11.线程切换框架RxJava的实现原理12.消息通知EventBus的实现原理13.图片加载库（Fresco、Glide、Picasso）实现原理14.消息推送PUSH原理15.TCP/IP、Http/Https、Socket的原理16.热更新、热修复、插件化17.Flutter、Kotlin、rn的学习","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://karmalove.github.io/tags/android/"}]},{"title":"Android异步消息处理机制分析","slug":"Android异步消息处理机制分析","date":"2019-07-30T04:23:34.000Z","updated":"2019-07-30T04:25:30.555Z","comments":true,"path":"2019/07/30/Android异步消息处理机制分析/","link":"","permalink":"https://karmalove.github.io/2019/07/30/Android异步消息处理机制分析/","excerpt":"","text":"Android异步消息处理机制分析 异步消息处理线程启动后会进入一个无限的循环体中，每循环一次，从内部的消息队列中取出一个消息，然后回调相应的消息处理函数，执行完成一个消息后则继续循环。若消息队列为空，线程则会阻塞等待。。。。。。 源码解析 异步消息处理机制涉及到主要三个类Handler、Looper、Message，其中Looper负责创建一个消息队列MessageQueue，然后进入一个无限循环体Loop中不断从该MessageQueue中读取信息，消息的创建者就是单个或多个Handler 1.Looper 对于Looper主要是prepare()和loop()这两个方法 首先看prepare()方法的实现123456public static final void prepare()&#123; if(sThreadLocal.get()!=null)&#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(true));&#125; sThreadLocal是一个ThreadLocal对象，它可以在一个线程中存储变量。可以看到上面的代码将一个Looper实例set入ThreadLocal，并且判断了Loop实例是否为null，否则抛出异常。这说明了Looper.prepare()方法不能调用两次，同时也保证了一个线程中只有一个Looper实例 * 再看一下Looper的构造方法实现 1private","categories":[],"tags":[]},{"title":"2019年讀書清單","slug":"2019-book","date":"2019-06-26T07:08:41.000Z","updated":"2019-06-26T07:20:44.541Z","comments":true,"path":"2019/06/26/2019-book/","link":"","permalink":"https://karmalove.github.io/2019/06/26/2019-book/","excerpt":"","text":"2019年讀書清單 《期權投資策略》 《偉大的博弈 華爾街金融帝國的崛起》 《戰勝一切市場的人》 《投資最重要的事》 《債務危機》 《原則》 《一個投機者的告白》 《逃不開的經濟週期：歷史，理論與投資現實》 《濤動週期論 經濟週期決定人生財富的命運》 《乾隆時代的得與失》","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"https://karmalove.github.io/tags/Book/"}]},{"title":"投資反思","slug":"thinking","date":"2019-06-26T06:48:33.000Z","updated":"2019-06-26T07:08:15.700Z","comments":true,"path":"2019/06/26/thinking/","link":"","permalink":"https://karmalove.github.io/2019/06/26/thinking/","excerpt":"","text":"如何從市場中那麼多人勝出？和別人的不同想法，比別人思考得更多，嚴格執行制訂的策略。 投資最重要的事 學習第二層思維 理解市場有效性及局限性 準確估計資產價值 價格與價值的關係 理解風險 識別風險 控制風險 關注週期 鐘擺意識 抵禦消極影響 逆向投資 尋找便宜貨 耐心等待機會 認識預測的局限性 正確認識自身 重視運氣 多元化投資 避免錯誤 增值的意義 合理預期","categories":[],"tags":[{"name":"Thinking","slug":"Thinking","permalink":"https://karmalove.github.io/tags/Thinking/"}]},{"title":"Python3.5安装requests错误","slug":"pip-install-fail","date":"2019-06-17T10:19:00.000Z","updated":"2019-06-18T02:11:07.332Z","comments":true,"path":"2019/06/17/pip-install-fail/","link":"","permalink":"https://karmalove.github.io/2019/06/17/pip-install-fail/","excerpt":"","text":"Python3.5安装requests错误not find a version that satisfies the requirement requests (from versions: ) No matching ......```1234567#### 解决方案* 更新pip * Python2.7更新方法: ```python -m pip install --upgrade pip * Python3.5更新方法: -m pip install --upgrade pip```12* Python国内网络问题，选择国内的镜像源来加速```pip install 包名 -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com 这个是豆瓣源--trusted-host pypi.douban.com这是为了获得ssl证书的认证，要不然会报错","categories":[],"tags":[]},{"title":"無財作力，少有鬥智，既饒爭時，此其大經也","slug":"wucai","date":"2019-06-11T06:17:10.000Z","updated":"2019-06-11T07:08:50.023Z","comments":true,"path":"2019/06/11/wucai/","link":"","permalink":"https://karmalove.github.io/2019/06/11/wucai/","excerpt":"","text":"之前常常思考一个问题，一个家庭条件一般的人靠自己的努力究竟有多大概率实现财务自由，暂且将财务自由的标准设定为一線城市有车有房无负债，账户里有2000万元人民币现金。不考虑未来通胀的影响，如果不是天天换跑车玩票的话，这个规模的资产应该在中国大部分地方都可以算得上财务自由了。 以身边朋友为例，90%算得上是名校研究生毕业（不是在吹牛，高中两届同学100多个人，最差的本科大概就是大连理工、华北电力之类的），同学大多为普通人家的孩子，且分布在各行各业，很有代表性。上一届同学已经开始工作，毕业之后起薪4万~50万不等，年薪不到10万的同学大多是本科毕业回家乡那边工作，如果没有什么奇遇的话，估计此生很难实现财务自由，所以现实就是这么残酷，可能年轻时的一个选择就会使你走向另一条路。当然人生的风景有很多，回家过得幸福也令人羡慕，此处只讨论最俗的财富积累，不谈人生选择。排除掉10万以下的，也要把50万的排除，那货北大光华毕业，太特殊，我估计他只要正常工作，过个十几年单凭工资就能实现财务自由。剩下的第一年年薪中位数大概在15万左右，起步工资大家都差不多，但十年之后差别就会非常明显，一些努力的或者是人生际遇好的年薪过百万应该没任何问题，我判断这样的同学在一线城市的概率会更大一些，毕竟机会更多，但即使在一线城市，除非自己创业，否则也只能是保持现金流稳定，资产不会太多。 从企业获得的报酬天花板很明显，到一定程度之后再往上升就难了，一些发展前景不好的传统行业可能工资达到30-40万就卡住了。所以普通人想要获得财务自由，难度还是非常大的，不仅仅需要一直努力提升自己的实力，还要在恰当的时机进行有风险的重大判断，而且还要判断正确。题目中的“无财作力，少有斗智，既饶争时”出自《史记·货殖列传》，可以简单解释为在你无产时只能靠体力去赚钱，在你少产时就要靠智力去赚钱，在你财力雄厚的时候就要靠对时机的把握来赚钱。这也是普通人取得财务自由最容易实现的途径，年轻时通过努力工作升职加薪，工作十年八年之后，需要通过资源、智力使得待遇突破瓶颈，上升到另一个高度，但这还不够，也只能使你实现超市自由。资产的大幅度增值要么是靠风险，要么靠资源，单靠智力和运气的人凤毛麟角，靠资源不用多说，靠风险的话一些胆子大的十年前多买几套房子，如今单靠房租就自由了，也有的通过股市或者期货加杠杆，一夜暴富。之前一直不信有这样的人，直到朋友说学院的一个博士通过信用卡套了50万，这轮牛市至今干到1000万，他亲眼看过账户之后终于是信了。财富呈聚集效应，或者说马太效应，少的越来越少，多的越来越多，这哥们短短两年时间就进入了财务自由的门槛，实在令人羡慕。 那么问题来了，现在一穷二白，还不知道能找到什么样工作的我，该如何规划接下来这十几年，才能在40岁之前实现财务自由呢？暂且列一个大方向的规划吧，第一步：无财作力。找到一个好工作，进入一个前景广阔的行业，以目前来看，进入金融行业问题不大，最差也能找个私募混混，只是后期风险会更大，不如券商那么稳，但这不是我能决定的。第二步：少有斗智。努力工作十年，使得薪酬待遇大幅度提升，这一点受影响因素较多，很可能受到一些客观因素影响无法保持长期的努力，或者说运气不佳，努力之后没达到理想效果，对这点只能尽人事听天命。第三步：既饶争时。通过二级市场将稳定的现金流转化为资产的不断增值，这步是最重要的一步，一招棋错，可能导致满盘皆输。幸运的是我和朋友已经在年轻时建立了成熟、完善的投资体系，阿狗的系统回测7年20倍，即使未来十几年最终系统失效，完全不赚钱甚至赔钱，但只要我们不加杠杆，不搞期货，肯定是不会死在市场里的，这也是三轮股灾给我们最好的财富。二十年后最终的结果估计有三种：第一种，这三步进行的都比较顺利，那我们40岁之前就能实现财务自由；第二种，前两步走的一般，财务自由的时间就会推迟一些年；第三种，第三步走错，此生财务自由无望。如果中国像日本那样20年经济不增长，出现了传说中的“消失的二十年”，那我的梦也就不用再做了。 现在越发不敢在朋友圈发一些中二的状态了，加的人太杂，我又懒得分组，只能通过豆瓣偶尔意淫，小撸怡情，也算是个梳理自己思想的过程。今年25岁了，之前的人生可以说是屡战屡败，幸运的是我内心还能保持热血，保持中二，屡败屡战，不管龙还在不在，骑士都在燃烧。","categories":[],"tags":[{"name":"trading","slug":"trading","permalink":"https://karmalove.github.io/tags/trading/"}]},{"title":"Trading_diary","slug":"Trading-diary","date":"2019-05-30T06:43:44.000Z","updated":"2019-06-28T05:50:55.534Z","comments":true,"path":"2019/05/30/Trading-diary/","link":"","permalink":"https://karmalove.github.io/2019/05/30/Trading-diary/","excerpt":"","text":"2019年05月29日 買入PDD，買入理由：近段時間底部買入NIO，買入理由：歷史最低價格，但是感覺還不是最底部。 2019年05月30日 沒有交易，NIO果然跌了10%，又一次抄在半山腰，昨天判斷它會跌是因為財報利好消息影響股價不大，不斷有大單流出。PDD還是在那個區間震蕩。 2019年05月31日 没有交易，盘后时候冲动想买NIO、UXIN、TIGER。生怕错过历史最低位，其实这样的投资心理是不对的。大环境一天不稳定，都不是反弹的时候 2019年06月03日 買入NIO,覺得它會跌還是繼續買入，不知道是什麼原因，股價不斷創歷史新低。其他股票也是歷史最低了，例如TIGER，大環境不好的情況下，不要覺得它已經是底部了，沒有更低只有最低。只能採取分批入貨的策略，因為無法預測最底部。剩下能做的事情唯有等了。 2019年06月04日 沒有交易，美聯儲主席鮑威爾發表講話，暗示有降息的可能，推動股市上漲。 2019年06月05日 沒有交易，小非農數據不及預期，中概股普遍跌，昨天賺的兩千多刀，今晚又全部虧回去。 2019年06月06日 沒有交易，中概股普遍跌 2019年06月07日 沒有交易，美國大非農數據遠不及預期，市場認為美聯儲降息幾率大增，美股指數高開 2019年06月10日 沒有交易，美墨達成貿易協議，不征收關稅，美股指數高開。優信二手車盤前發佈財報，盤前高開13%，開盤后一度跌7%。NIO跌6個點，繼續深套。 2019年06月11日 沒有交易，掛2.54買入NIO，沒有成交。大盤都在跌。 2019年06月12日 掛2.53買入NIO-1000股，跌到2.50。一直在这个区间横盘 2019年06月13日 掛4.3買入TIGER成交220股，剩下的沒有成交 2019年06月14日 没有交易，TIGER历史新低4.09，NIO再次出现自燃事件，也是历史新低4.3.中概股普跌。 2019年06月17日 没有交易，TIGER盤中拉升35%，要研究總結一下是什麼情況下拉？美股普漲。繼續關注美聯儲會議講話。 2019年06月18日 沒有交易，TIGER跌4.51%，HUYA拉升9.55%，達到預期目標，要開始注意風險了。因為普習通話，中概股普遍漲，美股三大指數齊升。 2019年06月19日 沒有交易，美聯儲發表講話，把”耐心”刪除，預計7月份降息。美股三大指數繼續上升。 2019年06月20日 沒有交易，整體沒有什麼波動。 2019年06月21日 沒有交易，整體低迷。虧損中 2019年06月24日 賣出TSLA，根據交易量判斷短期會回調，所以賣出。 2019年06月25日 沒有交易，美股全線下跌，中概股也是跌。HUYA跌9%，空池剩餘65萬。為什麼每次升完都要跌，要好好找一下規律才行。 2019年06月26日 買入20190719 jd 29 put option。有點貿然行動，買入太早。 2019年06月27日 盤前2.5買入NIO 1000股，NIO電池問題，宣佈召回計劃，利空消息開盤跌，後面升了。說明股價穩定了。","categories":[],"tags":[{"name":"trading","slug":"trading","permalink":"https://karmalove.github.io/tags/trading/"}]},{"title":"交易总结","slug":"tran","date":"2019-05-27T08:35:54.000Z","updated":"2019-05-30T07:09:14.714Z","comments":true,"path":"2019/05/27/tran/","link":"","permalink":"https://karmalove.github.io/2019/05/27/tran/","excerpt":"","text":"交易总结 所谓顺势只是伪命题，这是分析师的语言，交易者语言里只有规则，让错误的单子尽可能少亏，让正确的单子尽可能多赚 很大一部分交易者之所以迷茫，正因为他们总是在寻找一些确定的东西，因为人对于不确定的事情是没有安全感的，但事实上，投机市场里面没有任何东西都是确定的，任何一个交易方法表面上看起来可能很简单，执行下去就可以了，但事实上并非如此，这里面包含很多交易者独特的属性在里面，他的知识结构，他的习惯，他的性格，他在交易中所经历的很多事情，这些都是交易的一部分。那么，即使告诉你一个方法，我用起来可能赚钱，但是你用它做单可能会亏损，因为很多在我看来是常识或者习惯的东西，而你不具备，我们的经历和认知是完全不一样的。所以，构成交易体系的工作只得靠自己。 如何一步步构建属于自己的规则？ 学会每天总结交易的得失，收盘后根据交易的明细总结，失败的单子为什么失败？如何处理才能亏损最小化？成功的单子为什么成功？如何处理才能利益最大化？学会写交易日记，把这些总结用文字记下来，方便以后查看。成功的一部分可以copy，错误的事情不能一而再再而三的去犯错。","categories":[],"tags":[{"name":"trading","slug":"trading","permalink":"https://karmalove.github.io/tags/trading/"}]},{"title":"王賢巧-Android開發工程師簡歷","slug":"work","date":"2019-03-19T02:30:51.000Z","updated":"2019-07-18T08:36:09.572Z","comments":true,"path":"2019/03/19/work/","link":"","permalink":"https://karmalove.github.io/2019/03/19/work/","excerpt":"","text":"联系方式 Phone：15812869246 Email：1026karma@gmail.com 个人信息 王贤巧/男/1993 3年Android移动开发经验 本科/广东科技学院计算机系 交換生/台灣中國科技大學資訊系 Blog：https://karmalove.github.io/ Github：https://github.com/karmalove 技能清单 熟悉 Android 应用框架设计，熟悉 Android 高性能编程及调优、熟悉多线程编程，熟练使用 AsyncTask，用多线程技术优化性能 熟悉蓝牙 ble 技术开发、了解 Android FFmpeg 视频压缩、视频直播 熟练使用 MVP 和 MVC、Retrofit 和 RxAndroid、RxJava、dageer2 熟悉 Android 事件分发机制、自定义控件、RecycleView 的使用、代码混淆和反编译 apk 熟悉 Android 的网络通信技术，对 http、https 和 socket 通信有一定的了解 了解常用的设计模式、熟练使用 Git、Svn、Jenkins 熟悉 Python、JavaScript、HTML、css 接触过flutter、React Native、kotlin 工作经历深圳市三体科技有限公司（2017/9~至今)点愿项目 （项目简介：一款在线\\下载看视频APP） 独立开发点愿Android客户端 播放器基于ijkplayer进行开发 IM功能基于融云IM库进行开发 视频（上传/下载）断点续传基于OKhttp和rxjava进行开发 视频磁力链接下载技术基于反编译迅雷so开发 推送功能集成（小米、华为、魅族、友盟、FCM） 爬虫功能基于jsoup、htmlcleaner解析 广告模块接入广点通、今日头条和自己公司广告模块 使用热修复技术在线更新 点传项目 （项目简介：基于WiFi热点点对点传输文件APP） 负责加入广告模块 负责接入推送 一键换机项目 （项目简介：基于WiFi-direct技术传输文件APP） 负责部分UI开发 负责传输逻辑处理 负责接入推送（阿里推送、华为推送） 深圳市黑漂科技有限公司（2016/7~2017/5)黑漂钓鱼项目（项目简介：基于用户钓鱼需求开发的钓鱼客户端和钓鱼商家端APP） 独立开发黑漂钓鱼商家版和钓友版Android客户端 Ubuntu搭建gitlab版本控制服务器 Jenkins和蒲公英自动打包 使用MVP+retrofit+rxjava+dagger2开发 搭建移动端自动化测试Appium平台，用Python编写测试脚本 东莞市猎声电子科技有限公司（2015/6~2016/6)we playing项目（项目简介：Android手机应用和蓝牙耳机通信记录运动数据的APP） 在项目负责蓝牙ble通信开发和地图开发 历史数据自定义折线图开发 上传Google play应用市场","categories":[],"tags":[{"name":"個人信息","slug":"個人信息","permalink":"https://karmalove.github.io/tags/個人信息/"}]},{"title":"Android OTG开发","slug":"android/android-otg","date":"2018-03-19T02:30:51.000Z","updated":"2019-03-20T10:20:30.348Z","comments":true,"path":"2018/03/19/android/android-otg/","link":"","permalink":"https://karmalove.github.io/2018/03/19/android/android-otg/","excerpt":"","text":"最近开发一个APP接触到要跟硬件通过otg通信。Google了一下，发现很少关于这方面的东西，看了一下官方文档的介绍","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://karmalove.github.io/tags/android/"},{"name":"otg","slug":"otg","permalink":"https://karmalove.github.io/tags/otg/"}]},{"title":"使用JitPack发布Android开源库","slug":"jitpack","date":"2017-03-19T10:30:51.000Z","updated":"2019-03-20T03:23:28.426Z","comments":true,"path":"2017/03/19/jitpack/","link":"","permalink":"https://karmalove.github.io/2017/03/19/jitpack/","excerpt":"","text":"平时我们Android开发的时候，为了不重复造轮子，经常用到第三方开源项目，有了Android studio的Gradle，我们就一句代码就可以依赖远程代码仓库了，这比eclipse方便多了。假如我们也想自己造轮子开源给别人用呢？可以用JitPack。比Maven Central、jCenter简单多了。 JitPack是什么？ JitPack是一个自定义的Maven仓库。 发布步骤1.新建一个Android项目 在Android studio下新建一个AndroidUtil项目 project 2.在AndroidUtil项目下新建一个library 新建一个library，名称随便写（你喜欢就好），这个library就是我们要push到JitPack开源的仓库 library 在library的build.gradle下添加以下代码： 12apply plugin: 'com.github.dcendents.android-maven' group='com.github.YourUsername' 在AndroidUtil项目下的根目录build.gradle添加以下代码插件版本可以去官网查看，尽量使用最新版本，在AndroidStudio 2.2 之后插件要使用 1.4.1 以上的版本。classpath &#39;com.github.dcendents:android-maven-gradle-plugin:1.4.1&#39; build 3.提交项目的GitHub此处省略一万个字 4.Release你的仓库或者给你的仓库打一个Tag(重点) image.png 5.将你的仓库地址提交到JitPack(重点) JitPack地址 image.png 6.将远程仓库接入到项目中 在项目根目录的build.gradle123456allprojects &#123; repositories &#123; jcenter() maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125; 2.在module的build.gradle下com.github.KarmaOS:AndroidUtil:v1.0.0 [参考文章]12","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://karmalove.github.io/tags/android/"}]},{"title":"Hello World","slug":"hello-world","date":"2015-03-19T02:30:51.000Z","updated":"2019-07-29T07:22:36.983Z","comments":true,"path":"2015/03/19/hello-world/","link":"","permalink":"https://karmalove.github.io/2015/03/19/hello-world/","excerpt":"","text":"OkHttp源码分析需要了解以下三点 1.OkHttp请求流程2.网络请求缓存处理3.连接池 OkHttp请求get的步骤12345OkHttpClient client=new OkHtppClient();Request request=new Request.Builder() .url(url) .build();Response responde=client.newCall(request).execute(); 新建OkHttpClient客户端123456789OkHttpClient client = new OkHttpClient();public OkHttpClient() &#123; this(new Builder());&#125;OkHttpClient(Builder builder) &#123; ....&#125; ::可以看到，OkHttpClient使用了建造者模式，builder里面的可配置参数如下::123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public static final class Builder &#123; Dispatcher dispatcher;// 分发器 @Nullable Proxy proxy; List&lt;Protocol&gt; protocols; List&lt;ConnectionSpec&gt; connectionSpecs;// 传输层版本和连接协议 final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();// 拦截器 final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;(); EventListener.Factory eventListenerFactory; ProxySelector proxySelector; CookieJar cookieJar; @Nullable Cache cache; @Nullable InternalCache internalCache;// 内部缓存 SocketFactory socketFactory; @Nullable SSLSocketFactory sslSocketFactory;// 安全套接层socket 工厂，用于HTTPS @Nullable CertificateChainCleaner certificateChainCleaner;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。 HostnameVerifier hostnameVerifier;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。 CertificatePinner certificatePinner;// 证书锁定，使用CertificatePinner来约束哪些认证机构被信任。 Authenticator proxyAuthenticator;// 代理身份验证 Authenticator authenticator;// 身份验证 ConnectionPool connectionPool;// 连接池 Dns dns; boolean followSslRedirects; // 安全套接层重定向 boolean followRedirects;// 本地重定向 boolean retryOnConnectionFailure;// 重试连接失败 int callTimeout; int connectTimeout; int readTimeout; int writeTimeout; int pingInterval; // 这里是默认配置的构建参数 public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; ... &#125; // 这里传入自己配置的构建参数 Builder(OkHttpClient okHttpClient) &#123; this.dispatcher = okHttpClient.dispatcher; this.proxy = okHttpClient.proxy; this.protocols = okHttpClient.protocols; this.connectionSpecs = okHttpClient.connectionSpecs; this.interceptors.addAll(okHttpClient.interceptors); this.networkInterceptors.addAll(okHttpClient.networkInterceptors); ... &#125;## 2.同步请求流程Response response = client.newCall(request).execute();/*** Prepares the &#123;@code request&#125; to be executed at some point in the future.*/@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125;// RealCall为真正的请求执行者static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call;&#125;@Override public Response execute() throws IOException &#123; synchronized (this) &#123; // 每个Call只能执行一次 if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; // 通知dispatcher已经进入执行状态 client.dispatcher().executed(this); // 通过一系列的拦截器请求处理和响应处理得到最终的返回结果 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; // 通知 dispatcher 自己已经执行完毕 client.dispatcher().finished(this); &#125;&#125;Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 在配置 OkHttpClient 时设置的 interceptors； interceptors.addAll(client.interceptors()); // 负责失败重试以及重定向 interceptors.add(retryAndFollowUpInterceptor); // 请求时，对必要的Header进行一些添加，接受响应时，移除必要的Header interceptors.add(new BridgeInterceptor(client.cookieJar())); // 负责读取缓存直接返回、更新缓存 interceptors.add(new CacheInterceptor(client.internalCache())); // 负责和服务器建立连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; // 配置 OkHttpClient 时设置的 networkInterceptors interceptors.addAll(client.networkInterceptors()); &#125; // 负责向服务器发送请求数据、从服务器读取响应数据 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); // 使用责任链模式开启链式调用 return chain.proceed(originalRequest);&#125;// StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流// 和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; ... // Call the next interceptor in the chain. // 实例化下一个拦截器对应的RealIterceptorChain对象 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); // 得到当前的拦截器 Interceptor interceptor = interceptors.get(index); // 调用当前拦截器的intercept()方法，并将下一个拦截器的RealIterceptorChain对象传递下去,最后得到响应 Response response = interceptor.intercept(next); ... return response;&#125;","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://karmalove.github.io/tags/hexo/"}]}]}